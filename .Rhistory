dds.up  <- DESeqDataSetFromMatrix(countData = immuno.data,
colData = immuno.conds,
design = ~ conditions_p)
dds.up <- DESeq(dds.up)
res.up <- results(dds.up)
immuno.data.out.deseq.u<-list(resu=res.up)
save(immuno.data.out.deseq.u, file="./analysis/immuno.data.u.deseq.Rda")
library(ALDEx2, warn.conflicts=F)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
imumuno.data.out.edgeR.u <- list()
imumuno.data.out.edgeR.r <- list()
imumuno.data.out.edgeR.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#edgeR analysis
#PD1 setup
group_p <- factor(condsp)
design_p <- model.matrix(~group_p) #use data randomization from seqgendiff
#randomized without FP addition PD1
fit_rp <- glmQLFit(immuno.data,design_p) #uses original data (ie. no TP added)
qlf_rp <- glmQLFTest(fit_rp,coef=2)
edg.rp<-topTags(qlf_rp, n=nrow(immuno.data), adjust.method = "BH", sort.by = "none", p.value = 1)
resrp<-list(resu=edg.rp)
immuno.data.out.r[[i]] <- resrp
#randomized with FP addition PD1
fit_pp <- glmQLFit(datasp,design_p)
qlf_pp <- glmQLFTest(fit_pp,coef=2)
edg.pp<-topTags(qlf_pp, n=nrow(datasp), adjust.method = "BH", sort.by = "none", p.value = 1)
respp<-list(resu=edg.pp)
immuno.data.out.p[[i]] <- respp
}
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
immuno.data.out.deseq.u <- list()
immuno.data.out.deseq.r <- list()
immuno.data.out.deseq.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#DESeq2 analysis
#randomized without FP addition PD1
dds.rp.deseq  <- DESeqDataSetFromMatrix(countData = immuno.data,  #uses original data (no TP added)
colData = data.frame(condsp), #uses data randomization order from thin.immuno
design = ~ condsp)
dds.rp.deseq <- DESeq(dds.rp.deseq)
res.rp.deseq <- results(dds.rp.deseq)
resrp.deseq<-list(resr=res.rp.deseq)
immuno.data.out.deseq.r[[i]] <- resrp.deseq #added [[i]] and referenced list in line prior
#randomized with FP addition PD1
dds.thp.deseq  <- DESeqDataSetFromMatrix(countData = datasp,
colData = data.frame(condsp),
design = ~ condsp)
dds.thp.deseq <- DESeq(dds.thp.deseq)
res.thp.deseq <- results(dds.thp.deseq)
respp.deseq<-list(resp=res.thp.deseq)
immuno.data.out.deseq.p[[i]] <- respp.deseq
save(immuno.data.out.deseq.r, file="./analysis/immuno.data.r.deseq.Rda")
save(immuno.data.out.deseq.p, file="./analysis/immuno.data.p.deseq.Rda")
}
#unpermuted PD1
dds.up.deseq  <- DESeqDataSetFromMatrix(countData = immuno.data,
colData = immuno.conds,
design = ~ conditions_p)
dds.up.deseq <- DESeq(dds.up.deseq)
res.up.deseq <- results(dds.up.deseq)
immuno.data.out.deseq.u<-list(resu=res.up)
save(immuno.data.out.deseq.u, file="./analysis/immuno.data.u.deseq.Rda")
library(ALDEx2, warn.conflicts=F)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
imumuno.data.out.edgeR.u <- list()
imumuno.data.out.edgeR.r <- list()
imumuno.data.out.edgeR.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#edgeR analysis
#PD1 setup
group_p <- factor(condsp)
design_p <- model.matrix(~group_p) #use data randomization from seqgendiff
#randomized without FP addition PD1
fit_rp <- glmQLFit(immuno.data,design_p) #uses original data (ie. no TP added)
qlf_rp <- glmQLFTest(fit_rp,coef=2)
edg.rp<-topTags(qlf_rp, n=nrow(immuno.data), adjust.method = "BH", sort.by = "none", p.value = 1)
resrp.edgeR<-list(resu=edg.rp)
immuno.data.out.edgeR.r[[i]] <- resrp.edgeR
#randomized with FP addition PD1
fit_pp <- glmQLFit(datasp,design_p)
qlf_pp <- glmQLFTest(fit_pp,coef=2)
edg.pp<-topTags(qlf_pp, n=nrow(datasp), adjust.method = "BH", sort.by = "none", p.value = 1)
respp.edgeR<-list(resu=edg.pp.edgeR)
immuno.data.out.edgeR.p[[i]] <- respp.edgeR
}
library(ALDEx2, warn.conflicts=F)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
immuno.data.out.edgeR.u <- list()
immuno.data.out.edgeR.r <- list()
immuno.data.out.edgeR.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#edgeR analysis
#PD1 setup
group_p <- factor(condsp)
design_p <- model.matrix(~group_p) #use data randomization from seqgendiff
#randomized without FP addition PD1
fit_rp <- glmQLFit(immuno.data,design_p) #uses original data (ie. no TP added)
qlf_rp <- glmQLFTest(fit_rp,coef=2)
edg.rp<-topTags(qlf_rp, n=nrow(immuno.data), adjust.method = "BH", sort.by = "none", p.value = 1)
resrp.edgeR<-list(resu=edg.rp)
immuno.data.out.edgeR.r[[i]] <- resrp.edgeR
#randomized with FP addition PD1
fit_pp <- glmQLFit(datasp,design_p)
qlf_pp <- glmQLFTest(fit_pp,coef=2)
edg.pp<-topTags(qlf_pp, n=nrow(datasp), adjust.method = "BH", sort.by = "none", p.value = 1)
respp.edgeR<-list(resu=edg.pp.edgeR)
immuno.data.out.edgeR.p[[i]] <- respp.edgeR
}
library(ALDEx2, warn.conflicts=F)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
immuno.data.out.edgeR.u <- list()
immuno.data.out.edgeR.r <- list()
immuno.data.out.edgeR.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#edgeR analysis
#PD1 setup
group_p <- factor(condsp)
design_p <- model.matrix(~group_p) #use data randomization from seqgendiff
#randomized without FP addition PD1
fit_rp <- glmQLFit(immuno.data,design_p) #uses original data (ie. no TP added)
qlf_rp <- glmQLFTest(fit_rp,coef=2)
edg.rp<-topTags(qlf_rp, n=nrow(immuno.data), adjust.method = "BH", sort.by = "none", p.value = 1)
resrp.edgeR<-list(resu=edg.rp)
immuno.data.out.edgeR.r[[i]] <- resrp.edgeR
#randomized with FP addition PD1
fit_pp <- glmQLFit(datasp,design_p)
qlf_pp <- glmQLFTest(fit_pp,coef=2)
edg.pp<-topTags(qlf_pp, n=nrow(datasp), adjust.method = "BH", sort.by = "none", p.value = 1)
respp.edgeR<-list(resu=edg.pp)
immuno.data.out.edgeR.p[[i]] <- respp.edgeR
}
#unpermuted PD1
group_up<-factor(conditions_p)
design_up <- model.matrix(~group_up)
fit_up <- glmQLFit(y_pd1,design_up)
qlf_up <- glmQLFTest(fit_up,coef=2)
edg.up<-topTags(qlf_up, n=nrow(immuno.data), adjust.method = "BH", sort.by = "none", p.value = 1)
resup.edgeR<-list(resu=edg.up)
immuno.data.out.edgeR.u <- list(resup.edgeR)
#saving file
#PD1 save file
save(immuno.data.out.edgeR.u, file="./analysis/immuno.data.u.edger.Rda")
save(immuno.data.out.edgeR.r, file="./analysis/immuno.data.r.edger.Rda")
save(immuno.data.out.edgeR.p, file="./analysis/immuno.data.p.edger.Rda")
library(ALDEx2, warn.conflicts=F)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
#load datasets
#immuno/PD1 dataset loading
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p) #changed conditions to conditions_p to be consistent across datasets
#edgeR conditions for initial filtering
#PD1
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
immuno.data.out.aldex0.u <- list()
immuno.data.out.aldex.0.r <- list()
immuno.data.out.aldex.0.p <- list()
#for loop
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#ALDEX2 code added
#randomized without FP addition PD1
xrp.aldex0 <- aldex(immuno.data, conditions=condsp, gamma=1e-3) #uses original dataset but permuted conditions
resrp.aldex0<-list(resu=xrp)
immuno.data.out.aldex0.r[[i]] <- list(resrp.aldex0)
#randomized with FP addition PD1
xpp.aldex0 <- aldex(datasp, conditions=condsp, gamma=1e-3) #uses new dataset with permuted conditions
respp.aldex0<-list(resu=xpp.aldex0)
immuno.data.out.aldex0.p[[i]] <- list(respp.aldex0)
}
resrp.aldex0<-list(resu=xrp.aldex0)
immuno.data.out.aldex0.r[[i]] <- list(resrp.aldex0)
#randomized with FP addition PD1
xpp.aldex0 <- aldex(datasp, conditions=condsp, gamma=1e-3) #uses new dataset with permuted conditions
respp.aldex0<-list(resu=xpp.aldex0)
immuno.data.out.aldex0.p[[i]] <- list(respp.aldex0)
immuno.data.out.aldex0.u <- list()
immuno.data.out.aldex0.r <- list()
immuno.data.out.aldex0.p <- list()
for (i in 1:2){
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin.immuno <- thin_2group(immuno.data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
condsp <- as.vector(thin.immuno$designmat)   # permuted and thinned conditions and data
datasp <- thin.immuno$mat
#ALDEX2 code added
#randomized without FP addition PD1
xrp.aldex0 <- aldex(immuno.data, conditions=condsp, gamma=1e-3) #uses original dataset but permuted conditions
resrp.aldex0<-list(resu=xrp.aldex0)
immuno.data.out.aldex0.r[[i]] <- list(resrp.aldex0)
#randomized with FP addition PD1
xpp.aldex0 <- aldex(datasp, conditions=condsp, gamma=1e-3) #uses new dataset with permuted conditions
respp.aldex0<-list(resu=xpp.aldex0)
immuno.data.out.aldex0.p[[i]] <- list(respp.aldex0)
}
#unpermuted datasets
#unpermuted PD1
xup.aldex0 <- aldex(immuno.data, conditions=immuno.conds, gamma=1e-3)
library(ALDEx2, warn.conflicts=F)
library(ALDEx2)
library(ALDEx2)
.libPaths()
?for (variable in vector) {
}
# example function for DESeq2
# data is the raw counts, i.e., immuno from above
# conditions is conditions_p from above
# name is the name of the output file and must be in quotes
# nloops is the number of test loops
des.fun <- function(data, conditions, nloop=2){
#assign(paste("perf.a", "1", sep=""),5)
#perf.a1
conditions_p <- conditions
conds <- data.frame(conditions_p)
thin.data.out <- list()
data.out.deseq.u <- list()
data.out.deseq.r <- list()
data.out.deseq.p <- list()
#for loop
for (i in 1:nloop){
print(i)
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin <- thin_2group(data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
thin.data.out[[i]] <- thin
condsp <- as.vector(thin$designmat)   # permuted and thinned conditions and data
datasp <- thin$mat
#DESeq2 analysis
#randomized without FP addition PD1
dds.rp.deseq  <- DESeqDataSetFromMatrix(countData = data,  #uses original data (no TP added)
colData = data.frame(condsp), #uses data randomization order from thin
design = ~ condsp)
dds.rp.deseq <- DESeq(dds.rp.deseq, quiet=T)
res.rp.deseq <- results(dds.rp.deseq)
data.out.deseq.r[[i]] <- as.data.frame(res.rp.deseq@listData) #added [[i]] and referenced list in line prior
#randomized with FP addition PD1
dds.thp.deseq  <- DESeqDataSetFromMatrix(countData = datasp,
colData = data.frame(condsp),
design = ~ condsp)
dds.thp.deseq <- DESeq(dds.thp.deseq, quiet=T)
res.thp.deseq <- results(dds.thp.deseq)
data.out.deseq.p[[i]] <- as.data.frame(res.thp.deseq@listData)
}
print("done loop")
#unpermuted PD1
dds.up.deseq  <- DESeqDataSetFromMatrix(countData = data,
colData = conds,
design = ~ conditions_p)
dds.up.deseq <- DESeq(dds.up.deseq, quiet=T)
data.out.deseq.u <- results(dds.up.deseq)
data.des.u <- as.data.frame(data.out.deseq.u@listData)
return(list(conditions=conditions_p, thin.data=thin.data.out, u.data=data.des.u, r.data=data.out.deseq.r, p.data=data.out.deseq.p))
}
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
# loads the DESeq2 function to permute and add random true positives to the dataset
source('code/des.fun.R')
#####
# PD1 immunotherapy dataset
####
# pull the data and filter using edgeR
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
# immuno is the data table
# immuno.conds is the conditions for the unpermuted data
# N is the number of random instances
immuno.data.DESeq <- des.fun(immuno.data, conditions_p, 2)
library(seqgendiff, warn.conflicts=F)
library(edgeR, warn.conflicts=F)
library(DESeq2, warn.conflicts=F)
# loads the DESeq2 function to permute and add random true positives to the dataset
source('code/des.fun.R')
#####
# PD1 immunotherapy dataset
####
# pull the data and filter using edgeR
raw_counts <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm-GSE91061_raw_counts_GRCh38.p13_NCBI.tsv'
meta <- 'https://raw.githubusercontent.com/amurariu/usri/main/data/imm_metadata.txt'
immuno<-read.table(file=raw_counts, header = T, skip=35, sep='\t', row.names = 1)
m <- read.table(file=meta, header=F, row.names=1, sep='\t')
#establishing conditions for PD1
conditions_p <- rep("Pre", 109)
conditions_p[grep("_On",m)] <- "On"
immuno.conds <- data.frame(conditions_p)
#edgeR conditions for initial filtering
y_pd1 <- DGEList(counts=immuno, group=factor(conditions_p))
keep_pd1 <- filterByExpr(y_pd1)
y_pd1 <- y_pd1[keep_pd1,keep.lib.sizes=FALSE]
immuno.data <- y_pd1$counts #filtered base dataset
# immuno is the data table
# immuno.conds is the conditions for the unpermuted data
# N is the number of random instances
immuno.data.DESeq <- des.fun(immuno.data, conditions_p, 2)
save(immuno.data.DESeq, './analysis/immuno.data.Rda')
# example function for DESeq2
# data is the raw counts, i.e., immuno from above
# conditions is conditions_p from above
# name is the name of the output file and must be in quotes
# nloops is the number of test loops
des.fun <- function(data, conditions, nloop=2){
#assign(paste("perf.a", "1", sep=""),5)
#perf.a1
conditions_p <- conditions
conds <- data.frame(conditions_p)
thin.data.out <- list()
data.out.deseq.u <- list()
data.out.deseq.r <- list()
data.out.deseq.p <- list()
#for loop
for (i in 1:nloop){
print(i)
#thin_2group adds rnorm noise to 5% of the transcripts, generates TPs in the dataset
#generate thin_2group for each dataset as well as labelling for conditions and new dataset
#PD1
thin <- thin_2group(data, prop_null=0.95, alpha=0,
signal_fun = stats::rnorm,
signal_params = list(mean = 0, sd = 2))
thin.data.out[[i]] <- thin
condsp <- as.vector(thin$designmat)   # permuted and thinned conditions and data
datasp <- thin$mat
#DESeq2 analysis
#randomized without FP addition PD1
dds.rp.deseq  <- DESeqDataSetFromMatrix(countData = data,  #uses original data (no TP added)
colData = data.frame(condsp), #uses data randomization order from thin
design = ~ condsp)
dds.rp.deseq <- DESeq(dds.rp.deseq, quiet=T)
res.rp.deseq <- results(dds.rp.deseq)
data.out.deseq.r[[i]] <- as.data.frame(res.rp.deseq@listData) #added [[i]] and referenced list in line prior
#randomized with FP addition PD1
dds.thp.deseq  <- DESeqDataSetFromMatrix(countData = datasp,
colData = data.frame(condsp),
design = ~ condsp)
dds.thp.deseq <- DESeq(dds.thp.deseq, quiet=T)
res.thp.deseq <- results(dds.thp.deseq)
data.out.deseq.p[[i]] <- as.data.frame(res.thp.deseq@listData)
}
print("done loop")
#unpermuted PD1
dds.up.deseq  <- DESeqDataSetFromMatrix(countData = data,
colData = conds,
design = ~ conditions_p)
dds.up.deseq <- DESeq(dds.up.deseq, quiet=T)
data.out.deseq.u <- results(dds.up.deseq)
data.des.u <- as.data.frame(data.out.deseq.u@listData)
return(list(conditions=conditions_p, thin.data=thin.data.out, u.data=data.des.u, r.data=data.out.deseq.r, p.data=data.out.deseq.p))
}
